{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Strona g\u0142\u00f3wna","text":"<p>Dokumentacja ta zosta\u0142a stworzona na potrzeby zaj\u0119\u0107 z przedmiotu Programowanie w j\u0119zyku Python I prowadzonego przez Katedr\u0119 Geoinformatyki i Informatyki Stosowanej.</p> <p>Zawiera wst\u0119py teoretyczne, przyk\u0142ady, a tak\u017ce zadania do wykonania.</p>"},{"location":"#zadanie-0","title":"Zadanie 0","text":"<p>Info</p> <p>Zapoznaj si\u0119 z aforystycznymi zasadami, kt\u00f3re powinny towarzyszy\u0107 ka\u017cdemu programi\u015bcie, kt\u00f3ry chce tworzy\u0107 lepszy i czytelniejszy kod w Pythonie.</p> <p>Zaimportuj modu\u0142 this wykorzystuj\u0105c instrukcj\u0119 <code>import this</code>. </p>"},{"location":"zaj2/funkcje/","title":"Funkcje cz. 1","text":""},{"location":"zaj2/funkcje/#wstep","title":"Wst\u0119p","text":"<p>Funkcje pozwalaj\u0105 na organizowanie i strukturyzowanie kodu w logiczne bloki, kt\u00f3re mo\u017cna wielokrotnie wywo\u0142ywa\u0107. Dzi\u0119ki funkcjom mo\u017cemy upro\u015bci\u0107 programy, zmniejszy\u0107 ilo\u015b\u0107 powtarzaj\u0105cego si\u0119 kodu, a tak\u017ce sprawi\u0107, \u017ce nasze rozwi\u0105zania stan\u0105 si\u0119 bardziej modularne i \u0142atwiejsze do utrzymania.</p> <p>Zalety u\u017cywania funkcji:</p> <ul> <li> <p>Modularno\u015b\u0107: Dzielisz du\u017cy problem na mniejsze cz\u0119\u015bci, kt\u00f3re s\u0105 \u0142atwiejsze do zarz\u0105dzania.</p> </li> <li> <p>Ponowne wykorzystanie: Funkcj\u0119 mo\u017cna wywo\u0142ywa\u0107 wielokrotnie w r\u00f3\u017cnych miejscach programu.</p> </li> <li> <p>\u0141atwiejsze utrzymanie: Zmiana logiki w jednym miejscu (w funkcji) automatycznie wprowadza zmiany w ca\u0142ym programie.</p> </li> <li> <p>Czytelno\u015b\u0107: Funkcje pomagaj\u0105 tworzy\u0107 bardziej zrozumia\u0142y i uporz\u0105dkowany kod.</p> </li> </ul> <pre><code>import random\ndef generuj_losowa(seed=None):\n    # Ustawienie ziarna (seed) generatora liczb losowych\n    if seed is not None:\n        random.seed(seed)\n    # Generowanie losowej liczby z zakresu od 0 do 100\n    return random.randint(0, 100)\n\nliczba = generuj_losowa(seed=42)\nprint(f\"Wygenerowana liczba: {liczba}\")\n</code></pre> <p>Trzy kluczowe elementy ka\u017cdej funkcji:</p> <ol> <li> <p>S\u0142owo kluczowe s\u0142u\u017cace definiowaniu funkcji - <code>def</code></p> </li> <li> <p>Argumenty: definiowanie i podawane wewn\u0105trz <code>()</code></p> </li> <li> <p>Zwracane warto\u015bci - s\u0142owo kluczowe <code>return</code></p> </li> </ol>"},{"location":"zaj2/funkcje/#zadania","title":"Zadania","text":"<ol> <li> <p>Napisz funkcj\u0119 <code>zmien_wartosc(arg)</code>, kt\u00f3ra przyjmuje jeden argument i pr\u00f3buje zmodyfikowa\u0107 ten argument w r\u00f3\u017cny spos\u00f3b w zale\u017cno\u015bci od tego, czy jest on niemutowalny (w tym przypadku integerem) czy mutowalny (w tym przypadku list\u0105). </p> <ul> <li> <p>Je\u015bli jest list\u0105, wykonaj <code>arg[0] = 'kalafior'</code>. </p> </li> <li> <p>Je\u015bli jest integerem, wykonaj <code>arg = 65482652</code>.</p> </li> </ul> </li> </ol> <p>Wypisz przyk\u0142ady dla obu przypadk\u00f3w, wypisz warto\u015bci przed i po wykonaniu funkcji. Jak si\u0119 zachowuj\u0105 te obiekty? </p> <p>Tip</p> <p>Warto skorzysta\u0107 z funkcji <code>isinstance()</code>.</p> Teoria: mutowalne i niemutowalne obiekty w funkcjach <p>Kiedy zmienne s\u0105 przekazywane do funkcji jako argumenty, Python nie tworzy ich kopii, lecz przekazuje referencj\u0119 do oryginalnego obiektu. W zwi\u0105zku z tym spos\u00f3b, w jaki te obiekty zachowuj\u0105 si\u0119 wewn\u0105trz funkcji, zale\u017cy od ich typu \u2013 mutowalne lub niemutowalne.</p> <p>Obiekty mutowalne (np. listy, s\u0142owniki):</p> <p>Zmienne tego typu mog\u0105 by\u0107 modyfikowane w miejscu. Je\u015bli zostan\u0105 przekazane jako argumenty do funkcji i ich zawarto\u015b\u0107 zostanie zmieniona, zmiana ta wp\u0142ynie na oryginalny obiekt, kt\u00f3ry istnieje poza funkcj\u0105.</p> <p>Obiekty niemutowalne (np. liczby, napisy, krotki):</p> <p>Zmienne niemutowalne nie mog\u0105 by\u0107 modyfikowane w miejscu. Ka\u017cda pr\u00f3ba modyfikacji powoduje utworzenie nowego obiektu. Z tego powodu, zmiany wprowadzone wewn\u0105trz funkcji nie wp\u0142ywaj\u0105 na oryginalny obiekt poza funkcj\u0105.</p>"},{"location":"zaj2/funkcje/#dopasowywanie-argumentow","title":"Dopasowywanie argument\u00f3w","text":"<p>Funkcje mog\u0105 przyjmowa\u0107 argumenty na r\u00f3\u017cne sposoby, co umo\u017cliwia elastyczne przekazywanie danych. Kluczowe elementy to: argumenty pozycyjne, argumenty nazwane, warto\u015bci domy\u015blne, oraz specjalne operatory <code>*args</code> i <code>**kwargs</code>, kt\u00f3re pozwalaj\u0105 na przekazywanie zmiennej liczby argument\u00f3w.</p> <pre><code># dodanie warto\u015bci domy\u015blnych\ndef dodaj(a = 0, b = 0):\n    return a + b\n\n# argumenty pozycyjne przekazywane s\u0105 w podanej kolejno\u015bci\nprint(dodaj(3, 5))\n\n# argumenty nazwane mo\u017cna miesza\u0107\nprint(b=5, a=3)\n</code></pre> <p><code>*args</code> - zmienna liczba argument\u00f3w pozycyjnych</p> <p>Wszystkie dodatkowe argumenty s\u0105 zbierane w krotk\u0119, dzi\u0119ki czemu mo\u017cemy obs\u0142u\u017cy\u0107 wi\u0119cej argument\u00f3w, ni\u017c zdefiniowano w sygnaturze funkcji.</p> <pre><code>def suma(*liczby):\n    return sum(liczby)\n\nprint(suma(1, 2, 3))  # 6\nprint(suma(10, 20))\n</code></pre> <p><code>**kwargs</code> \u2013 zmienna liczba argument\u00f3w nazwanych</p> <p>Argumenty s\u0105 zbierane w s\u0142ownik, co umo\u017cliwia przekazanie wi\u0119kszej liczby argument\u00f3w nazwanych, ni\u017c przewidziano w sygnaturze funkcji.</p> <pre><code>def przedstaw_sie(**dane):\n    for klucz, wartosc in dane.items():\n        print(f\"{klucz}: {wartosc}\")\n\nprzedstaw_sie(imie=\"Jan\", wiek=30, miasto=\"Krak\u00f3w\")\n</code></pre> Mieszane u\u017cycie argument\u00f3w nie zawsze jest mo\u017cliwe <p>Wa\u017cne jest, aby przestrzega\u0107 kolejno\u015bci: najpierw argumenty pozycyjne, potem domy\u015blne, nast\u0119pnie <code>*args</code>, a na ko\u0144cu <code>**kwargs</code>.</p> <pre><code>def funkcja_mieszana(a, b=10, *args, **kwargs):\n    print(f\"a: {a}, b: {b}\")\n    print(f\"Argumenty dodatkowe (args): {args}\")\n    print(f\"Argumenty nazwane (kwargs): {kwargs}\")\n\nfunkcja_mieszana(1, 2, 3, 4, imie=\"Ania\", wiek=25)\n</code></pre> <p>Oraz kilka niepoprawnych wywo\u0142a\u0144:</p> <pre><code>funkcja_mieszana()\nfunkcja_mieszana(1, 2, 3, 4, 5, a=6)\nfunkcja_mieszana(1, 2, 3, imie=\"Jan\")\nfunkcja_mieszana(a=1, 20)\n</code></pre> <p>Sama definicja r\u00f3wnie\u017c mo\u017ce by\u0107 niepoprawna: <pre><code>def funkcja_mieszana(a=10, b):\n    print(f\"a: {a}, b: {b}\")\n</code></pre></p>"},{"location":"zaj2/funkcje/#zadania_1","title":"Zadania","text":"<ol> <li> <p>Napisz funkcj\u0119 <code>zamowienie_produktu</code>, kt\u00f3ra przyjmuje jeden obowi\u0105zkowy argument pozycyjny <code>nazwa_produktu</code> i dwa obowi\u0105zkowe argumenty nazwane: <code>cena</code> i <code>ilosc</code>. Funkcja powinna zwraca\u0107 tekst podsumowuj\u0105cy zam\u00f3wienie, zawieraj\u0105ce nazw\u0119 produktu, \u0142\u0105czn\u0105 cen\u0119 (cena * ilo\u015b\u0107) oraz ilo\u015b\u0107 zam\u00f3wionego produktu. </p> <ul> <li> <p>Stw\u00f3rz pust\u0105 list\u0119, do kt\u00f3rej wstawisz warto\u015bci zwracane przez funkcj\u0119 dla 3 r\u00f3\u017cnych produkt\u00f3w.</p> </li> <li> <p>Przeiteruj po wype\u0142nionej li\u015bcie, wy\u015bwietl teksty.</p> </li> <li> <p>Zmodyfikuj funkcj\u0119 tak, \u017ceby opr\u00f3cz tekstu podsumowuj\u0105cego zwraca\u0142a tak\u017ce warto\u015b\u0107 zam\u00f3wienia. </p> </li> <li> <p>Na koniec wy\u015bwietl sumaryczn\u0105 warto\u015b\u0107 zam\u00f3wie\u0144 (sum\u0119 z ka\u017cdego zam\u00f3wionego produktu). </p> </li> <li> <p>Dodaj warto\u015b\u0107 domy\u015bln\u0105 dla argumentu <code>ilosc</code> r\u00f3wn\u0105 1.</p> </li> </ul> </li> </ol> <p>Wa\u017cna informacja</p> <p>Wykorzystaj poni\u017cszy pocz\u0105tek definicji i go nie modyfikuj. Wymusi to podawanie argument\u00f3w po gwiazde jedynie w formie nazwanej.</p> <pre><code>def zamowienie_produktu(nazwa_produktu, *, cena, ilosc):\n</code></pre> <ol> <li>Napisz funkcj\u0119 <code>stworz_raport</code>, kt\u00f3ra przyjmuje dowoln\u0105 liczb\u0119 argument\u00f3w pozycyjnych (<code>*args</code>) i nazwanych (<code>**kwargs</code>). Argumenty pozycyjne powinny reprezentowa\u0107 numery ID produkt\u00f3w, a argumenty nazwane - informacje o tych produktach (np. nazwa, cena). Funkcja powinna tworzy\u0107 i wy\u015bwietla\u0107 raport, w kt\u00f3rym dla ka\u017cdego ID produktu podane s\u0105 szczeg\u00f3\u0142owe informacje na jego temat. </li> </ol> <p>Wywo\u0142anie funkcji powinno wygl\u0105da\u0107 nast\u0119puj\u0105co:</p> <pre><code>stworz_raport(101, 102, 101_nazwa=\"Kubek termiczny\", 101_cena=\"45.99 z\u0142\", 102_nazwa=\"D\u0142ugopis\", 102_cena=\"4.99 z\u0142\")\n</code></pre>"},{"location":"zaj2/funkcje/#funkcje-praktyczne-porady","title":"Funkcje - praktyczne porady","text":"<ol> <li>Funkcje powinny by\u0107 niezale\u017cne od otoczenia - argumenty jako input, return jako output.</li> <li>Unikamy zmiennych globalnych.</li> <li>Nie modyfikujemy argument\u00f3w mutowalnych.</li> <li>Funkcja ma by\u0107 ma\u0142a i mie\u0107 jeden cel.</li> <li>Nie zmieniamy warto\u015bci zmiennych z innych modu\u0142\u00f3w.</li> </ol>"},{"location":"zaj2/petle/","title":"P\u0119tle","text":""},{"location":"zaj2/petle/#petle-z-licznikami","title":"P\u0119tle z licznikami","text":"<p><code>range(n)</code> tworzy sekwencj\u0119 liczb od <code>0</code> do <code>n-1</code>. Mo\u017cemy u\u017cywa\u0107 tej funkcji do iteracji w p\u0119tli, np. do kontrolowania liczby powt\u00f3rze\u0144. <pre><code>for i in range(6):\n    print(f\"Licznik: {i}\")\n</code></pre></p>"},{"location":"zaj2/petle/#skanowanie-sekwencji","title":"Skanowanie sekwencji","text":"<p>Skanowanie sekwencji oznacza przechodzenie przez ka\u017cdy element w li\u015bcie, krotce, lub innym iterowalnym obiekcie.</p> <pre><code>owoce = ['jab\u0142ko', 'banan', 'pomara\u0144cza']\nfor owoc in owoce:\n    print(owoc)\n</code></pre>"},{"location":"zaj2/petle/#przetasowanie-sekwencji","title":"Przetasowanie sekwencji","text":"<p><code>range(len(x))</code> iteruje po indeksach sekwencji. Mo\u017ce by\u0107 u\u017cyte do manipulacji elementami na podstawie ich indeks\u00f3w.</p> <pre><code>owoce = ['jab\u0142ko', 'banan', 'pomara\u0144cza']\nfor i in range(len(owoce)):\n    owoce[i] = owoce[i].upper()\nprint(owoce)\n</code></pre>"},{"location":"zaj2/petle/#przechodzenie-niewyczerpujace","title":"Przechodzenie niewyczerpuj\u0105ce","text":"<p><code>range(0, len(x), 2)</code> lub <code>x[::2]</code></p> <pre><code>liczby = [1, 2, 3, 4, 5, 6]\nfor i in range(0, len(liczby), 2):\n    print(liczby[i])\n\n# Alternatywnie, z u\u017cyciem slicing\nprint(liczby[::2])\n</code></pre>"},{"location":"zaj2/petle/#listy-skadane","title":"Listy sk\u0142adane","text":"<p>Lista sk\u0142adana to wyra\u017cenie, kt\u00f3re pozwala na tworzenie nowych list w zwi\u0119z\u0142y spos\u00f3b, zwykle z u\u017cyciem p\u0119tli.</p> <pre><code>kwadraty = [x ** 2 for x in range(6)]\nprint(kwadraty)\n</code></pre> <pre><code>liczby = [1, 2, 3, 4, 5, 6]\nparzystosc = ['parzysta' if liczba % 2 == 0 else 'nieparzysta' for liczba in liczby]\nprint(parzystosc)\n</code></pre>"},{"location":"zaj2/petle/#przechodzenie-rownolege","title":"Przechodzenie r\u00f3wnoleg\u0142e","text":"<p><code>zip</code> umo\u017cliwia r\u00f3wnoleg\u0142e iterowanie po wielu sekwencjach, a <code>map</code> stosuje funkcj\u0119 do ka\u017cdego elementu sekwencji.</p> <p><pre><code>imiona = ['Anna', 'Jan', 'Piotr']\nwieki = [25, 30, 35]\nfor imie, wiek in zip(imiona, wieki):\n    print(f\"{imie} ma {wiek} lat\")\n</code></pre> <pre><code>def kwadrat(liczba):\n    return liczba ** 2\n\nliczby = [1, 2, 3, 4]\nkwadraty = list(map(kwadrat, liczby))\nprint(kwadraty)\n</code></pre></p>"},{"location":"zaj2/petle/#zadania","title":"Zadania","text":"<ol> <li> <p>Maj\u0105c dwie listy, <code>imiona = ['Anna', 'Jan', 'Ewa']</code> i <code>oceny = [5, 4, 3]</code>, u\u017cyj <code>zip</code> do stworzenia pary ka\u017cdego imienia z odpowiadaj\u0105c\u0105 mu ocen\u0105. Nast\u0119pnie, iteruj przez te pary, wy\u015bwietlaj\u0105c imi\u0119 wraz z ocen\u0105. Co si\u0119 stanie, je\u015bli listy b\u0119d\u0105 mia\u0142y r\u00f3\u017cne d\u0142ugo\u015bci? </p> </li> <li> <p>Maj\u0105c list\u0119 <code>liczby = [1, 2, 3, 4, 5]</code>, napisz funkcj\u0119 <code>kwadrat(x)</code>, kt\u00f3ra zwraca kwadrat liczby x. U\u017cyj map z t\u0105 funkcj\u0105, aby stworzy\u0107 now\u0105 list\u0119, w kt\u00f3rej ka\u017cdy element jest kwadratem odpowiadaj\u0105cego mu elementu z listy liczby. Wy\u015bwietl t\u0105 list\u0119.</p> </li> </ol>"},{"location":"zaj2/petle/#iteratory","title":"Iteratory","text":"<p>Iterator to obiekt w Pythonie, kt\u00f3ry pozwala na sekwencyjne przetwarzanie element\u00f3w kolekcji (np. list, krotek, zbior\u00f3w) bez za\u0142adowania ca\u0142ej struktury do pami\u0119ci. Iteratory umo\u017cliwiaj\u0105 przechodzenie po elementach jeden po drugim, co jest efektywne, szczeg\u00f3lnie przy pracy z du\u017cymi zbiorami danych.</p> <p>Ka\u017cda p\u0119tla <code>for</code> dzia\u0142a na iteratorach w tle.</p> Jak dzia\u0142aj\u0105 iteratory? <ul> <li>Ka\u017cdy obiekt, kt\u00f3ry ma metod\u0119 <code>__iter__()</code> i <code>__next__()</code>, jest iteratorem.</li> <li>Metoda <code>__iter__()</code> zwraca iterator, a <code>__next__()</code> zwraca kolejny element. Gdy element\u00f3w zabraknie, zg\u0142aszany jest wyj\u0105tek <code>StopIteration</code>.</li> </ul> Po co nam iteratory? <ul> <li>Efektywno\u015b\u0107 pami\u0119ciowa: Przetwarzaj\u0105 elementy na bie\u017c\u0105co, nie musz\u0105 trzyma\u0107 ca\u0142ej kolekcji w pami\u0119ci.</li> <li>Nieko\u0144cz\u0105ce si\u0119 sekwencje: Mo\u017cna tworzy\u0107 iteratory, kt\u00f3re generuj\u0105 niesko\u0144czone sekwencje danych, np. liczby losowe.</li> </ul> <pre><code>liczby = [1, 2, 3]\nit = iter(liczby)\nprint(next(it))\nprint(next(it))\nprint(next(it)) \n</code></pre>"},{"location":"zaj2/petle/#zadanie-dodatkowe","title":"Zadanie dodatkowe","text":"<p>Stw\u00f3rz w\u0142asny iterator (klas\u0119) <code>FibonacciIterator(max_elements)</code>, kt\u00f3ry generuje ci\u0105g liczb Fibonacciego. Ci\u0105g Fibonacciego to sekwencja, w kt\u00f3rej ka\u017cda kolejna liczba jest sum\u0105 dw\u00f3ch poprzednich, a zaczyna si\u0119 od 0 i 1.</p>"},{"location":"zaj2/przypisania/","title":"Przypisania","text":""},{"location":"zaj2/przypisania/#przypisania","title":"Przypisania","text":"<p>W Pythonie przypisania zmiennych tworz\u0105 referencje do obiekt\u00f3w, co oznacza, \u017ce zmienne dzia\u0142aj\u0105 jak wska\u017aniki. Zmienne nie przechowuj\u0105 samych warto\u015bci, lecz odnosz\u0105 si\u0119 do obiekt\u00f3w w pami\u0119ci.</p> <p>Zmienne s\u0105 tworzone automatycznie przy pierwszym przypisaniu warto\u015bci, bez potrzeby deklarowania ich wcze\u015bniej.</p> <p>Przed u\u017cyciem zmiennej nale\u017cy najpierw przypisa\u0107 do niej warto\u015b\u0107, w przeciwnym razie Python zg\u0142osi b\u0142\u0105d.</p> <p>Rozpakowywanie pozwala przypisa\u0107 wiele warto\u015bci do zmiennych jednocze\u015bnie, np. z listy, krotki lub innej iterowalnej struktury.</p> <pre><code>a, b, c = [1, 2, 3]\n\nskladniki = ['m\u0105ka', 'jajka', 'mleko', 'cukier', 's\u00f3l']\nbaza, *glowne_skladniki, przyprawy = skladniki\nprint(f\"Baza przepisu to {baza}\")\nprint(f\"G\u0142\u00f3wne sk\u0142adniki to {glowne_skladniki}\")\nprint(f\"A {przyprawy} to u\u017cyte przyprawy.\")\n</code></pre>"},{"location":"zaj2/przypisania/#zadania","title":"Zadania","text":"<ol> <li> <p>Maj\u0105c dan\u0105 krotk\u0119 <code>dane = (2024, 'Python', 3.8)</code>, przypisz ka\u017cdy element krotki do odpowiednich zmiennych: <code>rok</code>, <code>jezyk</code> i <code>wersja</code>. Wy\u015bwietl te zmienne. </p> </li> <li> <p>Maj\u0105c list\u0119 <code>oceny = [4, 3, 5, 2, 5, 4]</code>, przypisz pierwsz\u0105 warto\u015b\u0107 do zmiennej <code>pierwsza</code>, ostatni\u0105 do <code>ostatnia</code>, a pozosta\u0142e do listy <code>srodek</code>. Wykorzystaj <code>*</code> do zgromadzenia \u015brodkowych warto\u015bci. Wy\u015bwietl te zmienne. </p> </li> <li> <p>Dla krotki <code>info = ('Jan', 'Kowalski', 30, 'Polska', 'programista')</code>, przypisz imi\u0119 do zmiennej <code>imie</code>, nazwisko do <code>nazwisko</code>, a zaw\u00f3d do <code>zawod</code>, ignoruj\u0105c pozosta\u0142e warto\u015bci. Do ignorowania wykorzystaj znak <code>_</code>. Wy\u015bwietl przypisane zmienne.</p> </li> <li> <p>Maj\u0105c zagnie\u017cd\u017con\u0105 struktur\u0119 <code>dane = (2024, ['Python', 3.8, ('Stabilna', 'Wersja')])</code>, przypisz rok do zmiennej <code>rok</code>, nazw\u0119 j\u0119zyka do <code>jezyk</code>, wersj\u0119 do <code>wersja</code> i opis wersji do zmiennej <code>opis</code>. Wy\u015bwietl te zmienne. </p> </li> </ol>"},{"location":"zaj2/przypisania/#przypisania-z-wieloma-celami-i-wspodzielone-referencje","title":"Przypisania z wieloma celami i wsp\u00f3\u0142dzielone referencje","text":"<p>Wsp\u00f3\u0142dzielone referencje - zmienne mog\u0105 odnosi\u0107 si\u0119 do tego samego obiektu w pami\u0119ci. Zmiana jednego obiektu mo\u017ce mie\u0107 wp\u0142yw na inny, je\u015bli oba maj\u0105 t\u0119 sam\u0105 referencj\u0119.</p> <pre><code>a = b = [1, 2, 3]\nb[0] = 'zmieniono'\nprint(a, b)\n\n# Kopiowanie listy a do nowej listy c\nc = list(a)  # Mo\u017cna r\u00f3wnie\u017c u\u017cy\u0107 a[:] dla p\u0142ytkiej kopii\n\n# Modyfikacja pierwszego elementu w c\nc[0] = 'nowa warto\u015b\u0107'\n\n# Wy\u015bwietlenie wszystkich list\nprint(f\"Lista a: {a}, lista b: {b}, lista c: {c}\")\n</code></pre> Jaka p\u0142ytka i g\u0142\u0119boka kopia? <p>P\u0142ytka kopia tworzy now\u0105 instancj\u0119 obiektu, ale nie kopiuje obiekt\u00f3w wewn\u0119trznych (czyli element\u00f3w, do kt\u00f3rych ten obiekt odnosi si\u0119) (np. poprzez <code>copy.copy()</code>).</p> <p>G\u0142\u0119boka kopia tworzy now\u0105 instancj\u0119 obiektu, a tak\u017ce kopiuje wszystkie obiekty zagnie\u017cd\u017cone wewn\u0105trz niego. To oznacza, \u017ce g\u0142\u0119boka kopia tworzy ca\u0142kowicie now\u0105 struktur\u0119 danych, kt\u00f3ra nie wsp\u00f3\u0142dzieli referencji z oryginalnym obiektem (np. poprzez <code>copy.deepcopy()</code>).</p>"},{"location":"zaj2/przypisania/#zadania_1","title":"Zadania","text":"<ol> <li> <p>Stw\u00f3rz zmienn\u0105 a oraz b, u\u017cyj przypisania z wieloma celami i przypisz im list\u0119 [1, 2, 3]: <code>a = b = [1, 2, 3]</code>. Zmodyfikuj pierwszy element listy <code>b</code> przez przypisanie <code>b[0] = 'zmieniono'</code>. Wy\u015bwietl obie listy <code>a</code> i <code>b</code>, a nast\u0119pnie wyja\u015bnij, dlaczego zmiana w <code>b</code> wp\u0142yn\u0119\u0142a r\u00f3wnie\u017c na <code>a</code>. Czy listy s\u0105 obiektami mutowalnymi? </p> </li> <li> <p>Korzystaj\u0105c z poprzedniego przyk\u0142adu, utw\u00f3rz zmienn\u0105 <code>c</code> i przypisz jej kopi\u0119 listy <code>a</code> (mo\u017cesz u\u017cy\u0107 metody <code>list()</code> lub sk\u0142adni <code>a[:]</code>). Nast\u0119pnie zmodyfikuj pierwszy element w <code>c</code> i przypisz mu warto\u015b\u0107 <code>'nowa warto\u015b\u0107'</code>. Wy\u015bwietl listy <code>a</code>, <code>b</code> i <code>c</code>, zauwa\u017caj\u0105c, \u017ce tym razem zmiana w <code>c</code> nie wp\u0142yn\u0119\u0142a na <code>a</code> ani <code>b</code>. Wyja\u015bnij, dlaczego kopiowanie listy zapobieg\u0142o wsp\u00f3\u0142dzieleniu referencji. </p> </li> <li> <p>Utw\u00f3rz zmienn\u0105 <code>x</code> oraz <code>y</code>, przypisz im warto\u015b\u0107 <code>10</code> poprzez <code>x = y = 10</code>. Zwi\u0119ksz warto\u015b\u0107 <code>y</code> o 1 (np. <code>y = y + 1</code>). Wy\u015bwietl warto\u015bci <code>x</code> i <code>y</code>, a nast\u0119pnie wyja\u015bnij, dlaczego modyfikacja <code>y</code> nie wp\u0142yn\u0119\u0142a na warto\u015b\u0107 <code>x</code>. Czy integery s\u0105 obiektami mutowalnymi?</p> </li> </ol> Jakie obiekty mutowalne i niemutowalne? <p>W Pythonie obiekty dziel\u0105 si\u0119 na mutowalne (zmienne) i niemutowalne (niezmienne). Kluczow\u0105 r\u00f3\u017cnic\u0105 mi\u0119dzy nimi jest to, czy zawarto\u015b\u0107 obiektu mo\u017ce by\u0107 zmieniona w miejscu (bez tworzenia nowego obiektu) po jego utworzeniu.</p> <ul> <li>Obiekty mutowalne: Ich zawarto\u015b\u0107 mo\u017ce by\u0107 zmieniana po utworzeniu. Zmiany s\u0105 dokonywane bez tworzenia nowej referencji w pami\u0119ci. Lists, Dicts czy Sets.</li> <li>Obiekty niemutowalne: Nie mo\u017cna zmieni\u0107 ich zawarto\u015bci. Ka\u017cda pr\u00f3ba modyfikacji tworzy nowy obiekt. Integers, Floats, Tuples, Strings.</li> </ul> <pre><code># Przyk\u0142ad z obiektem mutowalnym - lista\nmut_list = [1, 2, 3]\nprint(\"Pocz\u0105tkowa lista:\", mut_list)\nprint(\"Pocz\u0105tkowy identyfikator listy:\", id(mut_list))\n\n# Zmiana elementu listy\nmut_list[0] = 'zmienione'\nprint(\"\\nLista po modyfikacji:\", mut_list)\nprint(\"Identyfikator listy po modyfikacji:\", id(mut_list))  # Ten sam identyfikator\n\n# Przyk\u0142ad z obiektem niemutowalnym - liczba ca\u0142kowita\nnum = 10\nprint(\"Pocz\u0105tkowa warto\u015b\u0107 num:\", num)\nprint(\"Pocz\u0105tkowy identyfikator num:\", id(num))\n\n# Zmiana warto\u015bci liczby\nnum = num + 1\nprint(\"\\nWarto\u015b\u0107 num po modyfikacji:\", num)\nprint(\"Identyfikator num po modyfikacji:\", id(num))  # Nowy identyfikator\n\n# Przyk\u0142ad z obiektem niemutowalnym - krotka\nprint(\"\\nObiekty niemutowalne (krotka):\")\nimmut_tuple = (1, 2, 3)\nprint(\"Pocz\u0105tkowa krotka:\", immut_tuple)\nprint(\"Pocz\u0105tkowy identyfikator krotki:\", id(immut_tuple))\n\n# Pr\u00f3ba modyfikacji krotki - TypeError\ntry:\n    immut_tuple[0] = 'zmienione'  # Spowoduje b\u0142\u0105d\nexcept TypeError as e:\n    print(\"\\nB\u0142\u0105d podczas modyfikacji krotki:\", e)\n</code></pre>"},{"location":"zaj2/przypisania/#przypisania-rozszerzone-i-wspodzielone-referencje","title":"Przypisania rozszerzone i wsp\u00f3\u0142dzielone referencje","text":"<p>Przypisania rozszerzone to operatory takie jak <code>+=</code>, <code>-=</code>, <code>*=</code>, kt\u00f3re modyfikuj\u0105 warto\u015b\u0107 zmiennej i przypisuj\u0105 wynik. <pre><code>x = 5\nx += 2  # to samo co x = x + 2\nprint(x)\n</code></pre></p>"},{"location":"zaj2/przypisania/#zadania_2","title":"Zadania","text":"<ol> <li>Wyzw\u00f3l nast\u0119puj\u0105cy kod, wy\u015bwietl K, L, M i N. Wyja\u015bnij w jaki spos\u00f3b konkatenacja zachowuje si\u0119 inaczej od przypisania rozszerzonego.</li> </ol> <pre><code>K = [1, 2] \nL = K\n# konkatenacja\nK = K + [3, 4] \nM = [1, 2] \nN = M\n# przypisanie rozszerzone\nM += [3, 4] \n</code></pre>"},{"location":"zaj2/przypisania/#sowa-zarezerwowane","title":"S\u0142owa zarezerwowane","text":"<p>S\u0142owa zarezerwowane w Pythonie maj\u0105 specjalne znaczenie i nie mog\u0105 by\u0107 u\u017cywane jako nazwy zmiennych. Przyk\u0142adami takich s\u0142\u00f3w s\u0105 <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>def</code>, <code>return</code> itp.</p>"},{"location":"zaj3/funkcje_02/","title":"Funkcje 02","text":"<p>Atrybuty i adnotacje lambda generatory</p> <p>(to z prezentacji na zaj02)</p>"},{"location":"zaj3/konwencja_nazewnictwa/","title":"Konwencja nazewnictwa","text":"<p>Python, podstawy konwencji nazewnictwa i z czego to wynika?</p>"}]}